# Rext Demo Project

This is a simple demo project that showcases all the features Rext *will* incorporate. This project was *not* created by Rext, but it is a good example of what Rext *will* be able to do.

## Getting Started

- In `example_rext_project` run `cargo run`.
- In `example_rext_project/frontend` run `npm i && npm run dev`

This spins up a Rust server listening on port 3000 and a Vite server running on port 5173.

The Rust server has a CORS bypass that allows these two ports to communicate via HTTP on `localhost`. In a real Rext app, we'll use `letsencrypt` self-signed certificates and domains on local host so we can use HTTPS and avoid CORS issues.

## Features

- **Frontend** - Written in Vue with Vue Router
- **Database** - a sqlite database for getting up and running quickly. Support for MySQL, Postgresql, and sqlite will be goals.
- **ORM** - an object relational model for accessing the database via [sea-orm](https://www.sea-ql.org/SeaORM/)
- **Web Server** - powered by [axum](https://crates.io/crates/axum)
- **Routing** - powered by the web server
- **Authentication** - simple yet secure authentication with [argon2](https://crates.io/crates/argon2) and [jsonwebtoken](https://crates.io/crates/jsonwebtoken).
- **SPA Navigation** - reactive authentication state with seamless single-page app experience
- **OpenAPI Generation** - Generates an OpenAPI document and serves SwaggerUI, Redoc, and Scalar pages
- **Middleware** - A simple middleware implementation for authentication
- **API Client** - A Type-safe API client generated by Hey API for types and API requests
- **Task Scheduler** - A task scheduler built on top of apalis
- **Job Queue** - A job queue built on top of apalis
- **Layered Architecture** - A clean separation of concerns between frontend and backend, with clear boundaries between each layer.

## How to use

- Navigate to `http://localhost:5173/` in your browser to view the Demo Vue app.
- Visit `/register` to create an account.
    - Email needs to be in email format, but it doesn't need to be real. Password is hashed with `argon2` on the backend.
    - If you get network errors, be sure you're on `localhost`, not `127.0.0.1`, same thing in concept but the CORS bypass is only set up for `localhost`.
- After registering, you can login at `/login`.
    - This passes you a token that is stored in your browser.
- This should route you to `/profile`.
    - This is a protected route, you can only access it when logged in. Should redirect to `/login` if logged out.
- Logout using the "Logout" button in the navigation bar, which removes the token from your browser and updates the UI in real-time.
- Visit the API docs at localhost:3000/scalar

### Admin Access

**Default Admin User:**
- **Email**: `admin@localhost.com`
- **Password**: `admin`
- **Note**: This user is automatically created when the application starts for the first time.

**Admin API Endpoints:**
- Admin login: `POST /api/v1/admin/login`
- View API documentation: `http://localhost:3000/scalar` (look for "Admin" tag)
- **Important**: Change the default admin password immediately after first login!

**Admin Panel Access:**
- **Frontend URL**: `http://localhost:5173/admin/login`
- **Default Credentials**: `admin@localhost.com` / `admin`
- **Features**: User management, request logs, database browser, system health
- **Documentation**: See `ADMIN_PANEL.md` for detailed usage instructions

## Next Steps
*A quick outline of the upcoming goals for this project*
- Establish sub-domains for local dev
    - This will be tested in this project, but it cannot be automated 100% by Rext. We can generate templates and self-signed certs, then provide a guide for the remaining steps. That's it.
- prepare deployment process
- Asset optimization - mostly build step, rust just needs to serve the proper headers and files
- Email Server - https://crates.io/crates/lettre
- Admin panel
- Tracing
- logging

## 🛠️ Admin Panel Implementation Plan

### Overview
This project implements a comprehensive admin panel with request logging, user management, and database inspection capabilities. The implementation follows the existing layered architecture patterns and provides a Django admin-like experience.

### Progress Summary

**✅ Completed Features:**
- Request logging middleware and audit_logs table
- Admin user roles and authentication system
- Complete admin API endpoints (auth, users, logs, database, health)
- Full admin frontend with AG Grid integration
- Admin user seeding with environment configuration
- Real-time system health monitoring

**🔧 Current Status:** Phase 4 - Advanced Features (In Progress)

### Phase 4: Advanced Features & Analytics

#### 4.1 Enhanced User Analytics
- [x] **User Activity Tracking**
  - Add `last_login` timestamp field to users table
  - Update when a user logs in
  - Calculate active users (logged in within last 7 days)
  - New user signup analytics (last 24 hours, 7 days, 30 days)

#### 4.2 System Performance Monitoring
- [x] **Real-time Request Monitoring**
  - WebSocket connection for live request streaming
  - Request rate limiting and throttling detection
  - Error rate monitoring and alerting
  - Response time percentiles (p50, p95, p99)

- [x] **Advanced Performance Metrics**
  - Database query performance analysis
  - Memory usage tracking
  - CPU utilization monitoring
  - Disk I/O statistics

#### 4.3 Infrastructure Health Dashboard
- [x] **System Information Display**
  - Environment detection (dev/staging/prod)
  - Database type and connection status
  - Server host, port, and protocol information
  - System uptime and start time

- [x] **Resource Monitoring**
  - Disk usage (total, used, available)
  - Network traffic (bytes sent/received)
  - Memory consumption patterns
  - Database connection pool status

#### 4.4 Data Export & Reporting
- [x] **Export Functionality**
  - CSV export for user data and audit logs
  - JSON API endpoints for external integrations
  - Scheduled report generation
  - Custom date range filtering

#### 4.5 Role-Based Access Control (RBAC)
- [ ] **Enhanced Permission System**
  - Create roles table with permissions ✅
  - Assign multiple roles to users ✅
  - Granular permission controls (read/write/admin)
  - Permission-based UI rendering

### Break Time!

We've got the roles table, and the updated user table. Now, we need to:
- The auto-import system seems to be having trouble... had to import lots of things in the Admin Users view
- Remove the is_admin field from the users table entirely- should not have 2 permissions systems. Too confusing.
- Update the 'don't delete yourself' safeguard so admin-roles cannot delete themselves instead of is_admin.
- Use a better font on the frontend UI. Giest or something.
- Clean up dead code attributes

#### 4.6 Advanced Admin Features
- [ ] **Admin User Management**
  - Admin user creation/deletion interface
  - Admin role assignment and management
  - Admin activity audit trail
  - Admin session management

**Environment Variables for Phase 4:**
```env
# Analytics Configuration
ENABLE_USER_ANALYTICS=true
ANALYTICS_RETENTION_DAYS=90

# Performance Monitoring
ENABLE_PERFORMANCE_MONITORING=true
METRICS_COLLECTION_INTERVAL=60

# Export Settings
ENABLE_DATA_EXPORT=true
MAX_EXPORT_RECORDS=10000

# RBAC Configuration
ENABLE_RBAC=true
DEFAULT_ADMIN_ROLE=super_admin
```

## Architecture

This project takes a layered approach to architecture with clear separation of concerns between frontend, backend, and database layers.

### Project Structure

```
example_rext_project/
├── backend/                   # Rust backend application
│   ├── main.rs                # Application entry point and server setup
│   ├── bridge/                # Web API layer (HTTP handlers, routes, middleware)
│   │   ├── mod.rs
│   │   ├── handlers/          # HTTP request handlers
│   │   │   ├── mod.rs
│   │   │   └── auth.rs        # Authentication handlers
│   │   ├── routes/            # API route definitions
│   │   │   ├── mod.rs
│   │   │   └── auth.rs        # Authentication routes
│   │   ├── middleware/        # HTTP middleware
│   │   │   ├── mod.rs
│   │   │   └── auth.rs        # Authentication middleware
│   │   └── types/             # API-specific types
│   │       ├── mod.rs
│   │       └── auth.rs        # Authentication types
│   ├── control/               # Business logic layer
│   │   └── services/          # Service implementations
│   ├── domain/                # Domain models and business rules
│   ├── entity/                # Database entity layer (Sea-ORM)
│   │   ├── mod.rs
│   │   └── models/            # Database entity models
│   │       ├── mod.rs
│   │       ├── prelude.rs     # Common entity imports
│   │       └── users.rs       # User entity model
│   └── infrastructure/        # Infrastructure concerns
│       ├── mod.rs
│       ├── app_error.rs       # Application error types
│       └── jwt_claims.rs      # JWT token claims
├── frontend/                  # Vue.js frontend application
│   ├── src/
│   │   ├── main.ts            # Frontend entry point
│   │   ├── App.vue            # Root Vue component
│   │   ├── appearance/        # Presentation layer
│   │   │   ├── components/    # Reusable Vue components
│   │   │   └── views/         # Page views
│   │   │       ├── HomeView.vue      # Landing page
│   │   │       ├── LoginView.vue     # User login form
│   │   │       ├── RegisterView.vue  # User registration form
│   │   │       └── ProfileView.vue   # User profile page
│   │   └── bridge/            # API client layer
│   │       ├── client/        # Generated API client
│   │       │   ├── client/    # Core client implementation
│   │       │   ├── core/      # Client utilities and types
│   │       │   ├── client.gen.ts     # Generated client code
│   │       │   ├── sdk.gen.ts # Generated SDK
│   │       │   └── types.gen.ts      # Generated types
│   │       └── router/        # Vue Router configuration
│   ├── e2e/                   # End-to-end tests (Playwright)
│   │   ├── tsconfig.json      # E2E TypeScript config
│   │   └── vue.spec.ts        # E2E test specifications
│   ├── config/                # Build and tooling configuration
│   │   └── unified.config.ts  # Unified configuration
│   ├── package.json           # Frontend dependencies
│   ├── vite.config.ts         # Vite build configuration
│   ├── tsconfig.json          # TypeScript configuration
│   └── eslint.config.ts       # ESLint configuration
├── migration/                 # Database migration system (Sea-ORM)
│   ├── src/
│   │   ├── lib.rs             # Migration registry and setup
│   │   ├── main.rs            # Migration runner
│   │   └── m20250720_000001_create_users.rs  # Users table migration
│   ├── Cargo.toml             # Migration dependencies
│   └── README.md              # Migration documentation
├── Cargo.toml                 # Rust workspace configuration
├── rext.toml                  # Rext framework configuration
├── example.env                # Environment variables template
└── README.md                  # Project documentation
```

### Architecture Layers

#### Backend (Rust)
- **Bridge Layer**: HTTP API endpoints, middleware, and request/response handling
- **Control Layer**: Business logic and service orchestration
- **Domain Layer**: Core business models and rules
- **Entity Layer**: Database models and ORM integration (Sea-ORM)
- **Infrastructure Layer**: Cross-cutting concerns (errors, JWT, etc.)

#### Frontend (Vue.js)
- **Appearance Layer**: UI components and page views
- **Bridge Layer**: API client and routing
- **Client Layer**: Generated type-safe API client

#### Database
- **Migration System**: Version-controlled database schema changes
- **Entity Models**: Type-safe database access with Sea-ORM

### Key Design Principles

1. **Separation of Concerns**: Clear boundaries between presentation, business logic, and data layers
2. **Type Safety**: Full TypeScript on frontend, strong typing in Rust backend
3. **API-First**: OpenAPI specification with generated clients
4. **Layered Architecture**: Clean separation between HTTP, business logic, and data access
5. **Generated Code**: Type-safe API clients and database entities generated from specifications